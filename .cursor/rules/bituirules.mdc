---
description: 
globs: 
alwaysApply: true
---
# Getting Started Documentation

Learn how to get started using Bits in your app.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Welcome to Bits UI, a collection of headless component primitives for Svelte 5 that prioritizes developer experience, accessibility, and flexibility. This guide will help you quickly integrate Bits UI into your Svelte application.

## Basic Usage

After installation, you can import and use Bits UI components in your Svelte files. Here's a simple example using the @Accordion component.

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root>
 <Accordion.Item>
  <Accordion.Header>
   <Accordion.Trigger>First</Accordion.Trigger>
  </Accordion.Header>
  <Accordion.Content>First accordion content</Accordion.Content>
 </Accordion.Item>
 <Accordion.Item>
  <Accordion.Header>
   <Accordion.Trigger>Second</Accordion.Trigger>
  </Accordion.Header>
  <Accordion.Content>Second accordion content</Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
```

## Adding Styles

Bits UI components are headless by design, meaning they ship with minimal styling. This gives you complete control over the appearance of your components. Each component that renders an HTML element exposes a `class` prop and `style` prop that you can use to apply styles to the element.

### Styling with TailwindCSS or UnoCSS

If you're using a CSS framework like TailwindCSS or UnoCSS, you can pass the classes directly to the components:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root class="mx-auto w-full max-w-md">
 <Accordion.Item class="mb-2 rounded-md border border-gray-200">
  <Accordion.Header class="bg-gray-50 transition-colors hover:bg-gray-100">
   <Accordion.Trigger
    class="flex w-full items-center justify-between p-4 text-left font-medium"
   >
    <span>Tailwind-styled Accordion</span>
    <svg
     class="h-5 w-5 transform transition-transform"
     xmlns="http://www.w3.org/2000/svg"
     fill="none"
     viewBox="0 0 24 24"
     stroke="currentColor"
    >
     <path
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      d="M19 9l-7 7-7-7"
     />
    </svg>
   </Accordion.Trigger>
  </Accordion.Header>
  <Accordion.Content class="p-4 text-gray-700">
   This accordion is styled using Tailwind CSS classes.
  </Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
```
### Styling with Data Attributes

Each Bits UI component applies specific data attributes to the underlying HTML elements. You can use these attributes to target components in your global styles:

1. 
   Check the API Reference for each component to determine its data attributes
2. 
   Use those attributes in your CSS selectors

+layout.svelte

```svelte
<script lang="ts">
 import { Button } from "bits-ui";
 import "../app.css";
</script>
<Button.Root>Click me</Button.Root>
```

app.css

```css
[data-button-root] {
 height: 3rem;
 width: 100%;
 background-color: #3182ce;
 color: white;
 border-radius: 0.375rem;
 padding: 0.5rem 1rem;
 font-weight: 500;
}
[data-button-root]:hover {
 background-color: #2c5282;
}
```

With this approach, every `Button.Root` component will have these styles applied to it automatically.

## TypeScript Support

Bits UI is built with TypeScript and provides comprehensive type definitions. When using TypeScript, you'll get full type checking and autocompletion:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
 // TypeScript will validate these props
 const accordionMultipleProps: Accordion.RootProps = {
  type: "multiple",
  value: ["item-1"], // type error if value is not an array
 };
 const accordionSingleProps: Accordion.RootProps = {
  type: "single",
  value: "item-1", // type error if value is an array
 };
</script>
```

# Child Snippet Documentation

Learn how to use the `child` snippet to render your own elements.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

The `child` snippet is a powerful feature that gives you complete control over the rendered elements in Bits UI components, allowing for customization while maintaining accessibility and functionality.

## When to Use It

You should use the `child` snippet when you need:

- Svelte-specific features like transitions, animations, actions, or scoped styles  
- Integration with custom components in your application  
- Precise control over the DOM structure  
- Advanced composition of components ## Basic Usage

Many Bits UI components have default HTML elements that wrap their content. For example, `Accordion.Trigger` renders a `<button>` element by default:

```svelte
<button {...props}>
 {@render children()}
</button>
```

When you need to customize this element, the `child` snippet lets you take control:

```svelte
<script lang="ts">
 import MyCustomButton from "$lib/components";
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger>
 {#snippet child({ props })}
  <MyCustomButton {...props}>Toggle Item</MyCustomButton>
 {/snippet}
</Accordion.Trigger>

<Accordion.Trigger>
 {#snippet child({ props })}
  <button {...props} class="scoped-button">Toggle Item</button>
 {/snippet}
</Accordion.Trigger>
<style>
 .scoped-button {
  background-color: #3182ce;
  color: #fff;
 }
</style>
```

In this example:

- The `props` parameter contains all necessary attributes and event handlers
- The `{...props}` spread applies these to your custom element/component
- You can add scoped styles, transitions, actions, etc. directly to the element ## How It Works

When you use the `child` snippet:

1. 
   The component passes all internal props and your custom props passed to the component via the `props` snippet parameter
2. 
   You decide which element receives these props
3. 
   The component's internal logic continues to work correctly

### Behind the Scenes

Components that support the `child` snippet typically implement logic similar to:

```svelte
<script lang="ts">
 // Bits UI component internal logic
 let { child, children, ...restProps } = $props();
 const trigger = makeTrigger();
 // Merge internal props with user props
 const mergedProps = $derived(mergeProps(restProps, trigger.props));
</script>
{#if child}
 {@render child({ props: mergedProps })}
{:else}
 <button {...mergedProps}>
  {@render children?.()}
 </button>
{/if}
```

## Working with Props

### Custom IDs & Attributes

To use custom IDs, event handlers, or other attributes, pass them to the component first:

```svelte
<Accordion.Trigger
 id="my-custom-id"
 data-testid="accordion-trigger"
 onclick={() => console.log("clicked")}
>
 {#snippet child({ props })}
  <button {...props}>Open accordion item</button>
 {/snippet}
</Accordion.Trigger>
```

The `props` object will now include:

- Your custom ID ( `id="my-custom-id"` )
- Your data attribute ( `data-testid="accordion-trigger"` )
- Your click event handler, properly merged with internal handlers  
- All required ARIA attributes and internal event handlers ## Combining with Svelte Features

You can apply Svelte-specific features to your custom elements, such as transitions, actions, and scoped styles:

```svelte
<Accordion.Trigger>
 {#snippet child({ props })}
  <div {...props} use:myCustomAction class="my-custom-trigger">
  </div>
 {/snippet}
</Accordion.Trigger>
<style>
 .my-custom-trigger {
  background-color: #3182ce;
  color: #fff;
 }
</style>
```

## Floating Components

Floating content components (tooltips, popovers, dropdowns, etc.) require special handling due to their positioning requirements.

### Required Structure

For floating components, you must use a two-level structure:

1. 
   An **outer wrapper element** with `{...wrapperProps}` 2. 
   An **inner content element** with `{...props}` ```svelte
<Popover.Content>
 {#snippet child({ wrapperProps, props, open })}
  {#if open}
   <div {...wrapperProps}>
    <div {...props}>
    </div>
   </div>
  {/if}
 {/snippet}
</Popover.Content>
```

### Important Rules for Floating Content

- The wrapper element with `{...wrapperProps}` must remain **unstyled**
- Positioning is handled by the wrapper element; styling goes on the inner content element  
- The `open` parameter lets you conditionally render the content, triggering Svelte transitions
- Always maintain this two-level structure to ensure proper positioning and behavior ### Components Requiring Wrapper Elements

The following components require a wrapper element:

- `Combobox.Content` - `DatePicker.Content` - `DateRangePicker.Content` - `DropdownMenu.Content` - `LinkPreview.Content` - `Menubar.Content` - `Popover.Content` - `Select.Content` - `Tooltip.Content` ## Examples

### Basic Custom Element

```svelte
<Collapsible.Trigger>
 {#snippet child({ props })}
  <button {...props}>
   <Icon name="star" />
   <span>Favorite</span>
  </button>
 {/snippet}
</Collapsible.Trigger>
```

### With Svelte Transitions

```svelte
<Dialog.Content>
 {#snippet child({ props, open })}
  {#if open}
   <div {...props} transition:scale={{ start: 0.95 }}>
    Dialog content with a scale transition
   </div>
  {/if}
 {/snippet}
</Dialog.Content>
```

### Floating Element Example

```svelte
<Tooltip.Content>
 {#snippet child({ wrapperProps, props, open })}
  {#if open}
   <div {...wrapperProps}>
    <div {...props} transition:fade>Custom tooltip content</div>
   </div>
  {/if}
 {/snippet}
</Tooltip.Content>
```

## Common Pitfalls

- **Missing props spread**: Always include `{...props}` on your custom element
- **Styling the wrapper**: Never style the wrapper element in floating components  
- **Direct children**: When using child, other children outside the snippet are ignored  
- **Missing structure**: For floating elements, forgetting the two-level structure will break positioning ## Related Resources

- @mergeProps Utility
- @Styling Guide  
- @Transitions Guide

# Ref Documentation

Learn about the $bindable ref prop.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

The `ref` prop provides direct access to the underlying HTML elements in Bits UI components, enabling you to manipulate the DOM when necessary.

## Basic Usage

Every Bits UI component that renders an HTML element exposes a `ref` prop that you can bind to access the rendered element. This is particularly useful for programmatically manipulating the element, such as focusing inputs or measuring dimensions.

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
 let triggerRef = $state<HTMLButtonElement | null>(null);
 function focusTrigger() {
  triggerRef?.focus();
 }
</script>
<button onclick={focusTrigger}>Focus trigger</button>
<Accordion.Trigger bind:ref={triggerRef}>Trigger content</Accordion.Trigger>
```

## With Child Snippet

Bits UI uses element IDs to track references to underlying elements. This approach ensures that the `ref` prop works correctly even when using the @child snippet.

### Simple Delegation Example

The `ref` binding will automatically work with delegated child elements/components.

```svelte
<script lang="ts">
 import CustomButton from "./CustomButton.svelte";
 import { Accordion } from "bits-ui";
 let triggerRef = $state<HTMLButtonElement | null>(null);
 function focusTrigger() {
  triggerRef?.focus();
 }
</script>
<Accordion.Trigger bind:ref={triggerRef}>
 {#snippet child({ props })}
  <CustomButton {...props} />
 {/snippet}
</Accordion.Trigger>
```

### Using Custom IDs

When you need to use a custom `id` on the element, pass it to the parent component first so it can be correctly registered with the `ref` binding:

```svelte
<script lang="ts">
 import CustomButton from "./CustomButton.svelte";
 import { Accordion } from "bits-ui";
 let triggerRef = $state<HTMLButtonElement | null>(null);
 const myCustomId = "my-custom-id";
</script>
<Accordion.Trigger bind:ref={triggerRef} id={myCustomId}>
 {#snippet child({ props })}
  <CustomButton {...props} />
 {/snippet}
</Accordion.Trigger>
```

### Common Pitfalls

Avoid setting the `id` directly on the child component/element, as this breaks the connection between the `ref` binding and the element:

```svelte
<Accordion.Trigger bind:ref={triggerRef}>
 {#snippet child({ props })}
  <CustomButton {...props} id="my-custom-id" />
 {/snippet}
</Accordion.Trigger>
```

In this example, the `Accordion.Trigger` component can't track the element because it doesn't know the custom ID.

## Why Possibly `null`?

The `ref` value may be `null` until the component mounts in the DOM. This behavior is consistent with native DOM methods like `getElementById` which can return `null`.

## Creating Your Own `ref` Props

To implement the same ref pattern in your custom components, Bits UI provides a @WithElementRef type helper. This enables you to create type-safe components that follow the same pattern.

```svelte
<script lang="ts">
 import { WithElementRef } from "bits-ui";
 import type { HTMLButtonAttributes } from "svelte/elements";
 // Define props with the ref type
 let {
  ref = $bindable(null),
  children,
  ...rest
 }: WithElementRef<
  HTMLButtonAttributes & {
   yourPropA: string;
   yourPropB: number;
  },
  HTMLButtonElement
 > = $props();
</script>
<button bind:this={ref} {...rest}>
 {@render children?.()}
</button>
```

# Transitions Documentation

Learn how to use transitions with Bits UI components.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

Svelte Transitions are one of the awesome features of Svelte. Unfortunately, they don't play very nicely with components, due to the fact that they rely on various directives like `in:`, `out:`, and `transition:`, which aren't supported by components.

In previous version of Bits UI, we had a workaround for this by exposing a ton of `transition*` props on the components that we felt were most likely to be used with transitions. However, this was a bit of a hack and limited us to *only* Svelte Transitions, and users who wanted to use other libraries or just CSS were left out.

With Bits UI for Svelte 5, we've completely removed this workaround and instead exposed props and snippets that allow you to use any animation or transitions library you want.

## The Defaults

By default, Bits UI components handle the mounting and unmounting of specific components for you. They are wrapped in a component that ensures the component waits for transitions to finish before unmounting.

You can use any CSS transitions or animations you want with this approach, which is what we're doing in the various example components in this documentation, using @tailwindcss-animate.

## Force Mounting

On each component that we conditionally render, a `forceMount` prop is exposed. If set to `true`, the component will be forced to mount in the DOM and become visible to the user. You can use this prop in conjunction with the @delegated `child` snippet to conditionally render the component and apply Svelte Transitions or another animation library.

The `child` snippet exposes a prop that you can use to conditionally render the element and apply your transitions.

```svelte
<script lang="ts">
 import { Dialog } from "bits-ui";
 import { fly } from "svelte/transition";
</script>
<Dialog.Root>
 <Dialog.Content forceMount>
  {#snippet child({ props, open })}
   {#if open}
    <div {...props} transition:fly>
    </div>
   {/if}
  {/snippet}
 </Dialog.Content>
</Dialog.Root>
```

In the example above, we're using the `forceMount` prop to tell the component to forcefully mount the `Dialog.Content` component. We're then using the `child` snippet to delegate the rendering of the `Dialog.Content` to a `div` element which we can apply our props and transitions to.

We understand this isn't the prettiest syntax, but it enables us to cover every use case. If you intend to use this approach across your application, it's recommended to create a reusable component that handles this logic, like so:

MyDialogContent.svelte

```svelte
<script lang="ts">
 import type { Snippet } from "svelte";
 import { fly } from "svelte/transition";
 import { Dialog, type WithoutChildrenOrChild } from "bits-ui";
 let {
  ref = $bindable(null),
  children,
  ...restProps
 }: WithoutChildrenOrChild<Dialog.ContentProps> & {
  children?: Snippet;
 } = $props();
</script>
<Dialog.Content bind:ref {...restProps} forceMount={true}>
 {#snippet child({ props, open })}
  {#if open}
   <div {...props} transition:fly>
    {@render children?.()}
   </div>
  {/if}
 {/snippet}
</Dialog.Content>
```

Which can then be used alongside the other `Dialog.*` components:

```svelte
<script lang="ts">
 import { Dialog } from "bits-ui";
 import MyDialogContent from "$lib/components/MyDialogContent.svelte";
</script>
<Dialog.Root>
 <Dialog.Trigger>Open Dialog</Dialog.Trigger>
 <Dialog.Portal>
  <Dialog.Overlay />
  <MyDialogContent>
   <Dialog.Title>Dialog Title</Dialog.Title>
   <Dialog.Description>Dialog Description</Dialog.Description>
   <Dialog.Close>Close</Dialog.Close>
   <div>Other dialog content</div>
  </MyDialogContent>
 </Dialog.Portal>
</Dialog.Root>
```

### Floating Content Components `Content` components that rely on Floating UI require a slight modification to how the `child` snippet is used.

For example, if we were to use the `Popover.Content` component, we need to add a wrapper element within the `child` snippet, and spread the `wrapperProps` snippet prop to it.

```svelte
<script lang="ts">
 import { Popover } from "bits-ui";
 import { fly } from "svelte/transition";
</script>
<Popover.Root>
 <Popover.Trigger>Open Popover</Popover.Trigger>
 <Popover.Portal>
  <Popover.Content forceMount>
   {#snippet child({ wrapperProps, props, open })}
    {#if open}
     <div {...wrapperProps}>
      <div {...props} transition:fly>
      </div>
     </div>
    {/if}
   {/snippet}
  </Popover.Content>
 </Popover.Portal>
</Popover.Root>
```

# Styling Documentation

Learn how to style Bits UI components.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

We ship almost zero styles with Bits UI by design, giving you complete flexibility when styling your components. For each component that renders an HTML element, we expose the `class` and `style` props to apply styles directly to the component.

## Styling Approaches

### CSS Frameworks

If you're using a CSS framework like @TailwindCSS or @UnoCSS, simply pass the classes to the component:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="h-12 w-full bg-blue-500 hover:bg-blue-600">Click me</Accordion.Trigger>
```

### Data Attributes

Each Bits UI component applies specific data attributes to its rendered elements. These attributes provide reliable selectors for styling across your application.

app.css

```css
/* Target all Accordion.Trigger components */
[data-accordion-trigger] {
 height: 3rem;
 width: 100%;
 background-color: #3182ce;
 color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
 import "../app.css";
 let { children } = $props();
</script>
{@render children()}
```

Now every `Accordion.Trigger` component will have the styles applied to it.

### Global Classes

Alternatively, you can use global class names:

app.css

```css
.accordion-trigger {
 height: 3rem;
 width: 100%;
 background-color: #3182ce;
 color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
 import "../app.css";
 let { children } = $props();
</script>
{@render children()}
```

Use the global class with the component:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="accordion-trigger">Click me</Accordion.Trigger>
```

### Scoped Styles

To use Svelte's scoped styles, use the `child` snippet to bring the element into your component's scope. See the @Child Snippet documentation for more information.

MyAccordionTrigger.svelte

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger>
 {#snippet child({ props })}
  <button {...props} class="my-accordion-trigger"> Click me! </button>
 {/snippet}
</Accordion.Trigger>
<style>
 .my-accordion-trigger {
  height: 3rem;
  width: 100%;
  background-color: #3182ce;
  color: #fff;
 }
</style>
```

### Style Prop

All Bits UI components that render an element accept a style prop as either a string or an object of CSS properties. These are merged with internal styles using the @`mergeProps` function.

```svelte
<Accordion.Trigger style="background-color: #3182ce; color: white; padding: 1rem;">
 Click me
</Accordion.Trigger>

<Accordion.Trigger style={{ backgroundColor: "#3182ce", color: "white", padding: "1rem" }}>
 Click me
</Accordion.Trigger>
```

## Styling Component States

Bits UI components may expose state information through data attributes and CSS variables, allowing you to create dynamic styles based on component state.

### State Data Attributes

Components apply state-specific data attributes that you can target in your CSS:

```css
/* Style the Accordion.Trigger when open */
[data-accordion-trigger][data-state="open"] {
 background-color: #f0f0f0;
 font-weight: bold;
}
/* Style the Accordion.Trigger when closed */
[data-accordion-trigger][data-state="closed"] {
 background-color: #ffffff;
}
/* Style disabled components */
[data-accordion-trigger][data-disabled] {
 opacity: 0.5;
 cursor: not-allowed;
}
```

See each component's API reference for its specific data attributes.

### CSS Variables

Bits UI components may expose CSS variables that allow you to access internal component values. For example, to ensure the `Select.Content` is the same width as the anchor (by default is the `Select.Trigger` unless using a `customAnchor`), you can use the `--bits-select-anchor-width` CSS variable:

```css
[data-select-content] {
 width: var(--bits-select-anchor-width);
 min-width: var(--bits-select-anchor-width);
 max-width: var(--bits-select-anchor-width);
}
```

See each component's API reference for specific CSS variables it provides.

### Example: Styling an Accordion

Here's an example styling an accordion with different states:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root>
 <Accordion.Item value="item-1">
  <Accordion.Trigger>Section 1</Accordion.Trigger>
  <Accordion.Content>Content for section 1</Accordion.Content>
 </Accordion.Item>
 <Accordion.Item value="item-2">
  <Accordion.Trigger disabled>Section 2 (Disabled)</Accordion.Trigger>
  <Accordion.Content>Content for section 2</Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
<style>
 /* Base styles */
 :global([data-accordion-item]) {
  border: 1px solid #e2e8f0;
  border-radius: 0.25rem;
  margin-bottom: 0.5rem;
 }
 /* Trigger styles based on state */
 :global([data-accordion-trigger]) {
  width: 100%;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
 }
 :global([data-accordion-trigger][data-state="open"]) {
  background-color: #f7fafc;
  border-bottom: 1px solid #e2e8f0;
 }
 :global([data-accordion-trigger][data-disabled]) {
  opacity: 0.5;
  cursor: not-allowed;
 }
 /* Content styles */
 :global([data-accordion-content]) {
  padding: 1rem;
 }
</style>
```

## Advanced Styling Techniques

### Combining Data Attributes with CSS Variables

You can combine data attributes with CSS variables to create dynamic styles based on component state. Here's how to animate the accordion content using the `--bits-accordion-content-height` variable and the `data-state` attribute:

```css
/* Basic transition animation */
[data-accordion-content] {
 overflow: hidden;
 transition: height 300ms ease-out;
 height: 0;
}
[data-accordion-content][data-state="open"] {
 height: var(--bits-accordion-content-height);
}
[data-accordion-content][data-state="closed"] {
 height: 0;
}
```

### Custom Keyframe Animations

For more control, use keyframe animations with the CSS variables:

```css
/* Define keyframes for opening animation */
@keyframes accordionOpen {
 0% {
  height: 0;
  opacity: 0;
 }
 80% {
  height: var(--bits-accordion-content-height);
  opacity: 0.8;
 }
 100% {
  height: var(--bits-accordion-content-height);
  opacity: 1;
 }
}
/* Define keyframes for closing animation */
@keyframes accordionClose {
 0% {
  height: var(--bits-accordion-content-height);
  opacity: 1;
 }
 20% {
  height: var(--bits-accordion-content-height);
  opacity: 0.8;
 }
 100% {
  height: 0;
  opacity: 0;
 }
}
/* Apply animations based on state */
[data-accordion-content][data-state="open"] {
 animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
[data-accordion-content][data-state="closed"] {
 animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
}
```

### Example: Animated Accordion

Here's an example of an accordion with a custom transition:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root type="single">
 <Accordion.Item value="item-1">
  <Accordion.Trigger>Section 1</Accordion.Trigger>
  <Accordion.Content>Content for section 1</Accordion.Content>
 </Accordion.Item>
 <Accordion.Item value="item-2">
  <Accordion.Trigger>Section 2</Accordion.Trigger>
  <Accordion.Content>Content for section 2</Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
<style>
 /* Base styles */
 :global([data-accordion-item]) {
  border: 1px solid #e2e8f0;
  border-radius: 0.25rem;
  margin-bottom: 0.5rem;
 }
 /* Trigger styles based on state */
 :global([data-accordion-trigger]) {
  width: 100%;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
 }
 :global([data-accordion-trigger][data-state="open"]) {
  background-color: #f7fafc;
  border-bottom: 1px solid #e2e8f0;
 }
 /* Content styles */
 :global([data-accordion-content]) {
  overflow: hidden;
  transition: height 300ms ease-out;
 }
 /* Define keyframes for opening animation */
 @keyframes -global-accordionOpen {
  0% {
   height: 0;
   opacity: 0;
  }
  80% {
   height: var(--bits-accordion-content-height);
   opacity: 0.8;
  }
  100% {
   height: var(--bits-accordion-content-height);
   opacity: 1;
  }
 }
 /* Define keyframes for closing animation */
 @keyframes -global-accordionClose {
  0% {
   height: var(--bits-accordion-content-height);
   opacity: 1;
  }
  20% {
   height: var(--bits-accordion-content-height);
   opacity: 0.8;
  }
  100% {
   height: 0;
   opacity: 0;
  }
 }
 /* Apply animations based on state */
 :global([data-accordion-content][data-state="open"]) {
  animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
 }
 :global([data-accordion-content][data-state="closed"]) {
  animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
 }
</style>
```
# Styling Documentation

Learn how to style Bits UI components.

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

We ship almost zero styles with Bits UI by design, giving you complete flexibility when styling your components. For each component that renders an HTML element, we expose the `class` and `style` props to apply styles directly to the component.

## Styling Approaches

### CSS Frameworks

If you're using a CSS framework like @TailwindCSS or @UnoCSS, simply pass the classes to the component:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="h-12 w-full bg-blue-500 hover:bg-blue-600">Click me</Accordion.Trigger>
```

### Data Attributes

Each Bits UI component applies specific data attributes to its rendered elements. These attributes provide reliable selectors for styling across your application.

app.css

```css
/* Target all Accordion.Trigger components */
[data-accordion-trigger] {
 height: 3rem;
 width: 100%;
 background-color: #3182ce;
 color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
 import "../app.css";
 let { children } = $props();
</script>
{@render children()}
```

Now every `Accordion.Trigger` component will have the styles applied to it.

### Global Classes

Alternatively, you can use global class names:

app.css

```css
.accordion-trigger {
 height: 3rem;
 width: 100%;
 background-color: #3182ce;
 color: #fff;
}
```

Import your stylesheet in your layout component:

+layout.svelte

```svelte
<script lang="ts">
 import "../app.css";
 let { children } = $props();
</script>
{@render children()}
```

Use the global class with the component:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger class="accordion-trigger">Click me</Accordion.Trigger>
```

### Scoped Styles

To use Svelte's scoped styles, use the `child` snippet to bring the element into your component's scope. See the @Child Snippet documentation for more information.

MyAccordionTrigger.svelte

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Trigger>
 {#snippet child({ props })}
  <button {...props} class="my-accordion-trigger"> Click me! </button>
 {/snippet}
</Accordion.Trigger>
<style>
 .my-accordion-trigger {
  height: 3rem;
  width: 100%;
  background-color: #3182ce;
  color: #fff;
 }
</style>
```

### Style Prop

All Bits UI components that render an element accept a style prop as either a string or an object of CSS properties. These are merged with internal styles using the @`mergeProps` function.

```svelte
<Accordion.Trigger style="background-color: #3182ce; color: white; padding: 1rem;">
 Click me
</Accordion.Trigger>

<Accordion.Trigger style={{ backgroundColor: "#3182ce", color: "white", padding: "1rem" }}>
 Click me
</Accordion.Trigger>
```

## Styling Component States

Bits UI components may expose state information through data attributes and CSS variables, allowing you to create dynamic styles based on component state.

### State Data Attributes

Components apply state-specific data attributes that you can target in your CSS:

```css
/* Style the Accordion.Trigger when open */
[data-accordion-trigger][data-state="open"] {
 background-color: #f0f0f0;
 font-weight: bold;
}
/* Style the Accordion.Trigger when closed */
[data-accordion-trigger][data-state="closed"] {
 background-color: #ffffff;
}
/* Style disabled components */
[data-accordion-trigger][data-disabled] {
 opacity: 0.5;
 cursor: not-allowed;
}
```

See each component's API reference for its specific data attributes.

### CSS Variables

Bits UI components may expose CSS variables that allow you to access internal component values. For example, to ensure the `Select.Content` is the same width as the anchor (by default is the `Select.Trigger` unless using a `customAnchor`), you can use the `--bits-select-anchor-width` CSS variable:

```css
[data-select-content] {
 width: var(--bits-select-anchor-width);
 min-width: var(--bits-select-anchor-width);
 max-width: var(--bits-select-anchor-width);
}
```

See each component's API reference for specific CSS variables it provides.

### Example: Styling an Accordion

Here's an example styling an accordion with different states:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root>
 <Accordion.Item value="item-1">
  <Accordion.Trigger>Section 1</Accordion.Trigger>
  <Accordion.Content>Content for section 1</Accordion.Content>
 </Accordion.Item>
 <Accordion.Item value="item-2">
  <Accordion.Trigger disabled>Section 2 (Disabled)</Accordion.Trigger>
  <Accordion.Content>Content for section 2</Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
<style>
 /* Base styles */
 :global([data-accordion-item]) {
  border: 1px solid #e2e8f0;
  border-radius: 0.25rem;
  margin-bottom: 0.5rem;
 }
 /* Trigger styles based on state */
 :global([data-accordion-trigger]) {
  width: 100%;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
 }
 :global([data-accordion-trigger][data-state="open"]) {
  background-color: #f7fafc;
  border-bottom: 1px solid #e2e8f0;
 }
 :global([data-accordion-trigger][data-disabled]) {
  opacity: 0.5;
  cursor: not-allowed;
 }
 /* Content styles */
 :global([data-accordion-content]) {
  padding: 1rem;
 }
</style>
```

## Advanced Styling Techniques

### Combining Data Attributes with CSS Variables

You can combine data attributes with CSS variables to create dynamic styles based on component state. Here's how to animate the accordion content using the `--bits-accordion-content-height` variable and the `data-state` attribute:

```css
/* Basic transition animation */
[data-accordion-content] {
 overflow: hidden;
 transition: height 300ms ease-out;
 height: 0;
}
[data-accordion-content][data-state="open"] {
 height: var(--bits-accordion-content-height);
}
[data-accordion-content][data-state="closed"] {
 height: 0;
}
```

### Custom Keyframe Animations

For more control, use keyframe animations with the CSS variables:

```css
/* Define keyframes for opening animation */
@keyframes accordionOpen {
 0% {
  height: 0;
  opacity: 0;
 }
 80% {
  height: var(--bits-accordion-content-height);
  opacity: 0.8;
 }
 100% {
  height: var(--bits-accordion-content-height);
  opacity: 1;
 }
}
/* Define keyframes for closing animation */
@keyframes accordionClose {
 0% {
  height: var(--bits-accordion-content-height);
  opacity: 1;
 }
 20% {
  height: var(--bits-accordion-content-height);
  opacity: 0.8;
 }
 100% {
  height: 0;
  opacity: 0;
 }
}
/* Apply animations based on state */
[data-accordion-content][data-state="open"] {
 animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
}
[data-accordion-content][data-state="closed"] {
 animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
}
```

### Example: Animated Accordion

Here's an example of an accordion with a custom transition:

```svelte
<script lang="ts">
 import { Accordion } from "bits-ui";
</script>
<Accordion.Root type="single">
 <Accordion.Item value="item-1">
  <Accordion.Trigger>Section 1</Accordion.Trigger>
  <Accordion.Content>Content for section 1</Accordion.Content>
 </Accordion.Item>
 <Accordion.Item value="item-2">
  <Accordion.Trigger>Section 2</Accordion.Trigger>
  <Accordion.Content>Content for section 2</Accordion.Content>
 </Accordion.Item>
</Accordion.Root>
<style>
 /* Base styles */
 :global([data-accordion-item]) {
  border: 1px solid #e2e8f0;
  border-radius: 0.25rem;
  margin-bottom: 0.5rem;
 }
 /* Trigger styles based on state */
 :global([data-accordion-trigger]) {
  width: 100%;
  padding: 1rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
 }
 :global([data-accordion-trigger][data-state="open"]) {
  background-color: #f7fafc;
  border-bottom: 1px solid #e2e8f0;
 }
 /* Content styles */
 :global([data-accordion-content]) {
  overflow: hidden;
  transition: height 300ms ease-out;
 }
 /* Define keyframes for opening animation */
 @keyframes -global-accordionOpen {
  0% {
   height: 0;
   opacity: 0;
  }
  80% {
   height: var(--bits-accordion-content-height);
   opacity: 0.8;
  }
  100% {
   height: var(--bits-accordion-content-height);
   opacity: 1;
  }
 }
 /* Define keyframes for closing animation */
 @keyframes -global-accordionClose {
  0% {
   height: var(--bits-accordion-content-height);
   opacity: 1;
  }
  20% {
   height: var(--bits-accordion-content-height);
   opacity: 0.8;
  }
  100% {
   height: 0;
   opacity: 0;
  }
 }
 /* Apply animations based on state */
 :global([data-accordion-content][data-state="open"]) {
  animation: accordionOpen 400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
 }
 :global([data-accordion-content][data-state="closed"]) {
  animation: accordionClose 300ms cubic-bezier(0.7, 0, 0.84, 0) forwards;
 }
</style>
```
# State Management Documentation

How to manage the state of Bits UI components

This is a documentation section that potentially contains examples, demos, and other useful information related to a specific part of Bits UI. When helping users with this documentation, you can ignore the classnames applied to the demos unless they are relevant to the user's issue.

State management is a critical aspect of modern UI development. Bits UI components support multiple approaches to manage component state, giving you flexibility based on your specific needs.

Each component's API reference will highlight what props are `bindable`. You can replace the `value` prop used in the examples on this page with any `bindable` prop.

## Two-Way Binding

The simplest approach is using Svelte's built-in two-way binding with `bind:`:

```svelte
<script lang="ts">
 import { ComponentName } from "bits-ui";
 let myValue = $state("default-value");
</script>
<button onclick={() => (myValue = "new-value")}> Update Value </button>
<ComponentName.Root bind:value={myValue}></ComponentName.Root>
```

### Why Use It?

- Zero-boilerplate state updates  
- External controls work automatically  
- Great for simple use cases ## Function Binding

For complete control, use a @Function Binding that handles both getting and setting values:

```svelte
<script lang="ts">
 import { ComponentName } from "bits-ui";
 let myValue = $state("default-value");
 function getValue() {
  return myValue;
 }
 function setValue(newValue: string) {
  // Only update during business hours
  const now = new Date();
  const hour = now.getHours();
  if (hour >= 9 && hour <= 17) {
   myValue = newValue;
  }
 }
</script>
<ComponentName.Root bind:value={getValue, setValue}></ComponentName.Root>
```

When the component wants to set the value from an internal action, it will invoke the setter, where you can determine if the setter actually updates the state or not.

### When to Use

- Complex state transformation logic  
- Conditional updates  
- Debouncing or throttling state changes  
- Maintaining additional state alongside the primary value  
- Integrating with external state systems

